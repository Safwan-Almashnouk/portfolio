<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="Artis/Project.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Artis</title>
    <link rel="icon" type="image/x-icon" href="LOGO.ico">
    <div class="header" id="myHeader">
              
        <div class="Buttons">
            <div class="logo">
                <a href="index.html">
                  <img src="LOGO copy.png" alt="Logo" />
                </a>
              </div>
            <a href="index.html" style="display: block; width: 100%; text-decoration: none;">
              <button type="button"style="width: 100%;">Home</button>
          </a>
            <a href="aboutMe.html" style="display: block; width: 100%; text-decoration: none;">
              <button type="button" style="width: 100%;">About Me</button>
            </a>
            <div class="dropdown">
              <button class="dropbtn">Projects
                <i class="fa fa-caret-down"></i>
              </button>
              <div class="dropdown-content">
                <a href="Artis.html">Artis Space Show</a>
                <a href="Forsaken.html">Forsaken Kingdoms</a>
                <a href="Witch&Knight.html">Witch&Knight</a>
                <a href="Elden.html">Elden Bling</a>
                <a href="Rift.html">Rift Guardian</a>
                <a href="">Galactic Chase</a>
              </div>
            </div>
            <a href="Contact.html" style="display: block; width: 100%; text-decoration: none;">
                <button type="button" style="width: 100%;"> Contact</button>
              </a>
          </div>
    </div>
</head>

<body>
   
    <article>
        <header>
            <h1>
                <div class="Title">Artis Planetarium Show.</div>
            </h1>
            <div class="Intro">
                
              
                <div class="IntroTextWrapper">
                  <div class="IntroTitle">
                    <h1>Introduction</h1>
                  </div>
                  <div class="IntroductionText">
                    <p>
                      This is a prototype commissioned by Artis for their Planetarium, created in XR-Lab as my first internship project. The project is a mixed reality show that uses the planetarium as a skybox.
                      It was designed to be enjoyed by multiple people at once, with the ability for the presenter to have complete control over what everyone sees.
                      The story, on the other hand, is simply about our place in the universe and how we are a significant part of it, even though we are so small. 
                    </p>
                  </div>
                </div>
                <div class="ProjectTags">
                  <div class="Tag"><b>Year- </b>2025</div>
                  <div class="Tag"><b>Length- </b>12 Weeks</div>
                  <div class="Tag"><b>Engine- </b>Unreal Engine</div>
                  <div class="Tag"><b>Language- </b>Blueprints</div> 
                  <div class="Tag"><b>Workflow- </b>Scrum, 2-week sprints</div>
                  <div class="Tag"><b>Team Size- </b>3 devs, 7 Artists</div>
                  <div class="Tag"><b>Role- </b>Developer</div>
                </div>
            </div>
              
        </header>
    </article>
   
    </div>
    <hr class="solid">
    <div class="Contribution">
        <div class="ContributionTitle">
            <h1>My Contribution</h1>
            <div class="MyContribution">
                <p>I wanted to try working on something I had never worked on before, so I decided to pick up three tasks. 
                The first and biggest was the multiplayer functionality of the prototype. The second was creating a controller to move through the show. The last was atom movement, which involved randomizing the movement of atoms.</p>
            </div>
        </div>
    </div>
    <hr class="solid">
    <div class="Table">
        <div class="Toc">
            <h1>
                Table of content
            </h1>
        </div>
      
        <div class="Content">
            <a href="#div_idScene">Scene Controller</a>
            <a href="#div_idSetUp">Multiplayer SetUp</a>
            <a href="#div_idCreate">Widget Interaction; Session Creation.</a>
            <a href="#div_idList">Widget Interaction; Session Listing and Joining.</a>
            <a href="#div_idMatch">Widget Interaction; Matchmaking</a>
            <a href="#div_idAll">Widget Interaction; Putting It All Together.</a>
            <a href="#div_idAtom">Atom Movement</a>
            <hr class="solid">
        </div>
    </div>
   
    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idScene"></div>
            <h1>
                Scene Controller
            </h1>
            <div class="SectionImage">
                <img src="/Artis/scenelevel.gif" alt="" srcset="">
            </div>
            <div class="Paragraph">
                <p>
                    The scene controller was a function only available to the host of the "game," so I made sure that only they had access to this ability.
                </p>
                <p>
                    The scene changer was something I had to design from scratch. We needed a way to play the artists' animations to display the story. Simply spawning and destroying objects wasn’t an option because we had to keep the system as lightweight as possible. Keeping everything in a single level wasn’t feasible either.   
                </p>
                <p>
                    After some research, I discovered sublevels—a way to hide components rather than destroy them when they weren't needed. But this led to a new challenge: how do I hide something in a way that ensures it's ready when the next sublevel is activated? I had an idea: what if every button press followed a simple sequence?
                </p>
                <p>
                   1. On the first press, states 0 and 1 are activated.
                </p>
                <p>
                    2. On the second press, state 0 is removed, state 1 remains, and state 2 is activated.
                </p>
                <p>
                    3. On the third press, state 1 disappears, state 2 stays, and state 3 becomes active.
                </p>
                <p>
                    To better illustrate this system, I asked ChatGPT to create a table that I could use as a reference.
                </p>

                <div class="SectionImage">
                    <img src="/Artis/SheetGPT.png" alt="" srcset="">
                </div>
            </div>
                <div class="BpShowcase">
                    <iframe src="https://blueprintue.com/render/9rghmor-/" scrolling="no" allowfullscreen></iframe>
                </div>
        </div>
    </div>
    <div class="Section">
        <div class="SectionTitle">
            <h1>
                Visual Sheets
            </h1>
        </div>
        <div class="SectionImage">
            <img src="/Artis/vs1.jpg" alt="" srcset="">
        </div>
        <div class="Paragraph">
            <p>
                First is the activation. It goes through these functions in that order.
                The first function is what loads the level and ensures that the order of unloading and loading is correct. When it reaches the end, it resets. 
            </p>
        </div>
        <div class="SectionImage">
            <img src="/Artis/vs2.png" alt="" srcset="">
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/7tsiwahq/" scrolling="no" allowfullscreen></iframe>
        </div>

        <div class="Paragraph">
            <p>
                The next step was to ensure the correct animation is playing. I created a list, an enum list, which I assigned each level's main object to by name. 
                That was then converted into data and placed into the event. The event then breaks the data down, ensures that the required Enum for the sequences are the same as the current and next loaded level, and plays it. 
            </p>
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/pfxcm_2p/" scrolling="no" allowfullscreen></iframe>
        </div>


    </div>
    <hr class="solid">
    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idSetUp"></div>
            <h1>
                Multiplayer Setup
            </h1>
        </div>

        <div class="Paragraph">
            <p>
                The first thing I did was create the game instance. A multiplayer game instance uses the built-in Unreal Engine online subsystem to host, join, and destroy sessions.
            </p>
            <p>
                This multiplayer system that I created uses both a local network and an online subsystem.
                The difference between an Online Subsystem and a Local Network can be understood with a simple analogy. 
            </p>
            <p>
                Imagine you and your best friend are on the same local network. If you have a letter for them, you simply walk over and hand it to them—fast and efficient, but only possible if you're in the same house (local network).
            </p>
            <p>
                However, if your friend lives in another city, you need a mailman (Online Subsystem), who relies on a postal service (such as Steam, Epic Games, or Unreal’s built-in services) to deliver the letter.
            </p>
        </div>

        <div class="SectionImage">
            <img src="/Artis/MultiplayerExample.png" alt="" srcset="">
        </div>

        <div class="Paragraph">
            <p>
                In short, a Local Network sends data directly between players, while an Online Subsystem routes data through external servers, allowing players from anywhere to connect.
            </p>
            <p>
                This instance is what will be called upon by all of the buttons on the multiplayer screen, which will be shown next. Without this instance, nothing will work as there will simply be no multiplayer to begin with.
            </p>
        </div>
        <div class="SectionImage">
            <img src="/Artis/House.png" alt="" srcset="">
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/k09t05do/" scrolling="no" allowfullscreen></iframe>
        </div>

    </div>
    <hr class="solid">
    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idCreate"></div>
            <h1>
                Widget Interaction; Session Creation. 
            </h1>
        </div>
        <div class="SectionImage">
            <img src="/Artis/CreateSession.png" alt="" srcset="">
        </div>
        <div class="Paragraph">
            <p>
                To be able to use any of the functions that I created in the previous blueprint, I needed to create widgets. A widget is a 3D UI element created through the UMG in your game world. You use Widget Blueprints for such things. The first widget I will explain is Session Creation.
            </p>
            <p>
                The buttons you have are as follows: Up Arrow for increasing the max players, Down Arrow for decreasing, Calibration map (which sends the players to the spatial anchor map, you can ignore this button), and finally, the Create button, which creates the session.
            </p>
            <p>
                After selecting the desired button and creating an OnClicked event, it runs an event that either decreases or increases the variable of Max players, sets it to a Text type, and places that as the variable for PlayerCap.
            </p>
        <div class="Paragraph">
            <p>
                The next event is Create Session. Similar to the previous function, upon creating an OnClicked event on the required button, the event of Create Session from the Multiplayer game instance is called, and you create a session with the data of the max players, whether LAN is used or not, and with the correct instance. 
            </p>
            <div class="SectionImage">
                <img src="/Artis/CreateSessionBP.png" alt="" srcset="">
            </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/95ywqexe/" scrolling="no" allowfullscreen></iframe>
        </div>
           
        </div>
        </div>
    </div>
    <hr class="solid">
    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idList"></div>
            <h1>Widget Interaction; Session Listing and Joining.</h1>
        </div>
        <div class="SectionImage">
            <img src="/Artis/listofSessions.png" alt="">
        </div>
        <div class="Paragraph">
            <p>
                The next step is viewing created sessions. A widget displays the session name, player count, and ping, along with a "Join" button.
            </p>
            <p>
                First, a custom event, Create Session Item, was made using the Blueprint Session Result variable. It retrieves the session name, player count, and max players, converts them to strings, and updates the UI.
            </p>
            <p>
                Finally, clicking "Join" triggers the Join Session event in the multiplayer instance, joining the session linked to the displayed data.
            </p>
        </div>
        <div class="SectionImage">
            <img src="/Artis/SessionJoin.png" alt="">
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/gy698eng/" scrolling="no" allowfullscreen></iframe>
        </div>
    </div>
    <hr class="solid">

    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idMatch"></div>
            <h1>
                Widget Interaction; Matchmaking
            </h1>
        </div>
        <div class="Paragraph">
            <p>
                To list sessions, a Search Sessions event is created. It uses the Find Sessions function from the multiplayer instance to gather available sessions. Each result creates a Session Item widget (from the previous step) and adds it to the panel, displaying session details.
            </p>
        </div>
        <div class="SectionImage">
            <img src="/Artis/sessionHolder.png" alt="">
        </div>
        <div class="Paragraph">
            <p>
                The Refresh event updates the list when the refresh button is clicked. It first clears the panel (via Clear Children) and then calls Search Sessions to find and display new sessions after a short delay.
            </p>
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/qlmz31lh/" scrolling="no" allowfullscreen></iframe>
        </div>
    </div>
    <hr class="solid">
    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idAll"></div>
            <h1>
                Widget Interaction; Putting It All Together.
            </h1>
        </div>
        <div class="SectionImage">
            <img src="/Artis/CompletedMP.jpg" alt="" srcset="">
        </div>
        <div class="Paragraph">
            <p>
                With all the widgets created, the next step is putting everything together. A new SessionUI widget blueprint is made, serving as a container for the main widgets—one for finding sessions and one for creating them. These are properly aligned, but this blueprint itself has no code.
            </p>
        </div>
        <div class="SectionImage">
            <img src="/Artis/UiCompleted.png" alt="">
            <img src="/Artis/UiSelected.png" alt="">
        </div>
        <div class="Paragraph">
            <p>
                Next, an actor is created and given a widget component, assigning it SessionUI to display the interface. Since VR doesn’t automatically handle widget interaction, this actor includes blueprint code to ensure smooth player interaction.
            </p>
            <p>
                The actor makes sure the UI is placed correctly and interacts properly. It first sets up the widget interaction class, positioning it correctly. Then, it tracks the player’s hand movements using the pointer index, allowing both hands to interact with the UI.
            </p>
            <p>
                Finally, it registers where the pointer last touched using Get Last Hit Result, capturing the exact location.
            </p>
            
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/ompratre/" scrolling="no" allowfullscreen></iframe>
        </div>
    </div>
    <hr class="solid">

    <div class="Section">
        <div class="SectionTitle">
            <div id="div_idAtom"></div>
            <h1>
                Atom movement
            </h1>
        </div>
        <div class="SectionImage">
            <img src="Artis/atomshowcase.gif" alt="" srcset="">
        </div>

        <div class="Paragraph">
            <p>
            Working on the atoms ended up taking the longest, which was rather suprising for me. It included a lot of math, and I wanted to make it as dry as possible, as such, I created a component. A component that can be attached to the 6 diffrent types of atoms. 
            </p>   
        </div>
        <div class="Paragraph">
            <p>
            First, we start with the beginplay of an indivual atom, which at the start, disables the tick, which is used to move the object. Here, it plays the looping animation of the atom, and gets the Begin function from the component.
            </p>
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/0etfw64x/" scrolling="no" allowfullscreen></iframe>
        </div>
        <div class="Paragraph">
            <p>
                The next part starts with it getting the current actor(atom)'s location. It then ensures that the tick function is disabled, gets the target position of where to go from Initilze pattern variable function, gets a small delay and enables the tick once more
            </p>
        </div>
        <div class="BpShowcase">
            <iframe src="https://blueprintue.com/render/pjis2fv5/" scrolling="no" allowfullscreen></iframe>
        </div>
        <div class="Paragraph">
            <p>
                This Blueprint sets up a starting and target position for the object. It begins by choosing a random distance (Radius) between 450 and 1800 units, placing the object somewhere along the edge of a circle.
            </p>
            <p>
                Using sine and cosine, it calculates X and Y positions for a circular layout, then adds a Z value to form a 3D starting point. A small Random Drift value between 80 and 800 is added to give the motion a natural, swaying feel. Finally, it sets the Target Position + some offset, readying the object for smooth, dynamic movement.
            </p>
        </div>
        <div class="SectionImage">
            <img src="Artis/atomRandomeness.png" alt="" srcset="">
        </div>

        <div class="Paragraph">
            <p>
                The next part is to check if is grabbed or not. If it is grabbed, it disables the tick, if not, let's say that you let go, it sets a variable called return timer to 0, sets a bool to true, and renables the tick function. However, if is grabbed, it actually saves the position where it was grabbed at. 
            </p>
        </div>
        <div class="SectionImage">
            <img src="Artis/GrabAndGrab.png" alt="">
        </div>

        <div class="Paragraph">
            <p>
                Finally, the tick, which ensures that the object is moving. Depending on weather the boolean early is true or not, it either moves it in it's looping idle function, or the one time movement of Return. 
            </p>
            <p>
                Idle ensures that it does not speed up at incredible speed and moves back and forth, moving it between StartPos and TargetPos. The alpha, which when it's 0, is at start, and 1 is at target, keeps increasing back and forth, ensuring that it moves back and forth smoothly.
            </p>
            <p>
                Return meanwhile uses the timer as the Alpha of Og pos and the current location, before getting that as a vector.
            </p>
            <P>
                When it gets both vectors from Idle and return, it then chooses depending on if it is moving to the og pos or not from the boolean, and makes that as the target of the moving actor. 
            </P>
        </div>

        <div class="SectionImage">
            <img src="Artis/Idle.png" alt="" srcset="">
            <img src="Artis/Return.png" alt="" srcset="">
            <img src="Artis/Screenshot 2025-04-09 141340.png" alt="" srcset="">
            <img src="Artis/dependacny.png" alt="" srcset="">
        </div>


    </div>
    <hr class="solid">
    <div class="Section">
        <div class="SectionTitle">
            <h1>
                Retrospective 
            </h1>
        </div>
        <div class="Paragraph">
            <p>
                Looking back at this project, there is not much I believe I could have done much better. Code readabilty is always there to improve, and keeping eveyrthing as dry as possible too. I think the use of more functions and function only variables would have also been a rather good idea.
            </p>
           
        </div>
    </div>
    <hr class="solid">
</body>
</html>
